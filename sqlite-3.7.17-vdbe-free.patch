# Ensure that comparison operators do not mess up the MEM_Dyn flag on registers
# when reverting affinity changes.
# Upstream original patch: https://www.sqlite.org/src/info/02e3c88fbf6abdcf

diff -up sqlite-src-3071700/src/vdbe.c.old sqlite-src-3071700/src/vdbe.c
--- sqlite-src-3071700/src/vdbe.c.old	2015-07-23 11:54:21.781280736 +0200
+++ sqlite-src-3071700/src/vdbe.c	2015-07-23 11:58:24.829703086 +0200
@@ -1852,7 +1852,13 @@ case OP_Ge: {             /* same as TK_
     affinity = pOp->p5 & SQLITE_AFF_MASK;
     if( affinity ){
       applyAffinity(pIn1, affinity, encoding);
+      testcase( (flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn) );
+      flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask);
+
       applyAffinity(pIn3, affinity, encoding);
+      testcase( (flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn) );
+      flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask);
+
       if( db->mallocFailed ) goto no_mem;
     }
 
@@ -1881,7 +1887,9 @@ case OP_Ge: {             /* same as TK_
   }
 
   /* Undo any changes made by applyAffinity() to the input registers. */
+  assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) );
   pIn1->flags = (pIn1->flags&~MEM_TypeMask) | (flags1&MEM_TypeMask);
+  assert( (pIn3->flags & MEM_Dyn) == (flags3 & MEM_Dyn) );
   pIn3->flags = (pIn3->flags&~MEM_TypeMask) | (flags3&MEM_TypeMask);
   break;
 }
